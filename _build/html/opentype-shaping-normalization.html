
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Normalization in OpenType shaping &#8212; OpenType Shaping Documents  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="normalization-in-opentype-shaping">
<h1>Normalization in OpenType shaping<a class="headerlink" href="#normalization-in-opentype-shaping" title="Permalink to this heading">¶</a></h1>
<section id="unicode-normalization">
<h2>Unicode normalization<a class="headerlink" href="#unicode-normalization" title="Permalink to this heading">¶</a></h2>
<p>Unicode defines algorithms for normalizing a sequence of input
codepoints into either a canonical composed form or a canonical
decomposed form. The purpose of these algorithms and of the defined
normalization forms is to generate equivalent representations of input
sequences regardless of variations in the order of the input sequences.</p>
<p>For example, a base letter with an attached mark might exist in
Unicode as a single codepoint, but an input sequence might consist of
the base letter codepoint followed by the combining mark
codepoint. Unicode normalization can be used to determine that the
“Letter, Mark” sequence is equivalent to the single codepoint. This
simplifies sorting, searching, string comparison, and many other common
tasks.</p>
<p>OpenType shaping utilizes Unicode normalization, but OpenType
shaping has a distinctly different goal: to select the best or most
appropriate representation of the input codepoint sequence that is
available in the active font.</p>
<section id="unicode-equivalence-and-decomposition">
<h3>Unicode equivalence and decomposition<a class="headerlink" href="#unicode-equivalence-and-decomposition" title="Permalink to this heading">¶</a></h3>
<p>Unicode defines two levels of <em>equivalence</em>: “canonical equivalence”
and “compatibility equivalence.”</p>
<p>Both of these equivalence relationships are stored as
<code class="docutils literal notranslate"><span class="pre">Decomposition_Mapping</span></code> properties for codepoints in the Unicode
Character Database. In a canonical equivalence relationship, a
codepoint will have a <code class="docutils literal notranslate"><span class="pre">Decomposition_Mapping</span></code> that lists either one or
two other codepoints. In a compatibility equivalence relationship, a
codepoint will instead have a <code class="docutils literal notranslate"><span class="pre">Decomposition_Mapping</span></code> that starts with
a formatting tag which is followed by either one or two other
codepoints.</p>
<blockquote>
<div><p>Note: Decomposition mappings typically map one input codepoint to
two output codepoints.</p>
<p>Decomposition mappings that produce one output codepoint are rare
and are defined in order to handle particular, uncommon encoding
circumstances. However, because such mappings exist, shaping engines
should not assume that all decomposition mappings produce exactly
two output codepoints.</p>
</div></blockquote>
<p>For shaping purposes, canonical equivalence is generally of greatest
concern. Canonical equivalence defines that sequences such as “Letter,
Mark” (a standalone base character followed by a combining-mark
character) are to be treated the same as “Letter-with-mark” (a
codepoint that includes both the base and the mark).</p>
<p>The canonical <code class="docutils literal notranslate"><span class="pre">Decomposition_Mapping</span></code>s are required for Unicode
normalization and, even outside of the Unicode normalization
algorithm, help shaping engines make the correct matches between
codepoint sequences and glyphs.</p>
<p>Compatibility equivalence is more akin to defining fallback
relationships, such as defining that a superscript numeral has the
same underlying meaning as the full-size numeral. If the active font
has no glyph for the superscript numeral codepoint, any decision as to
whether substituting the full-size numeral glyph, artifically scaling
the full-size numeral glyph, or displaying a <code class="docutils literal notranslate"><span class="pre">.notdef</span></code> glyph is the
desirable output is more likely to be a question left up to the
application layer or to the end user, rather than to be handled by the
shaping engine.</p>
<p>However, there may be compatibility equivalence relationships of
significant interest to shaping engines or to other components of a
text-rendering stack. For example, the Arabic Presentation Form
codepoints have defined compatibility equivalences that maps each one
to a codepoint in the Arabic block. Therefore, this information can be
used to enable fallback support for shaping older documents that
include Arabic Presentation Form text runs.</p>
</section>
<section id="unicode-normalization-forms">
<h3>Unicode normalization forms<a class="headerlink" href="#unicode-normalization-forms" title="Permalink to this heading">¶</a></h3>
<p>Unicode defines four “normalization forms,” two of which are focused
on canonical equivalence and two of which are focused on compatibility
equivalence.</p>
<p>The canonical equivalence forms are:</p>
<ul class="simple">
<li><p>Normalization Form D = <code class="docutils literal notranslate"><span class="pre">NFD</span></code></p>
<ul>
<li><p>All codepoints have gone through full, recursive canonical
decomposition</p></li>
</ul>
</li>
<li><p>Normalization Form C = <code class="docutils literal notranslate"><span class="pre">NFC</span></code></p>
<ul>
<li><p>All codepoints have gone through full, recursive canonical
decomposition, followed by full canonical composition</p></li>
</ul>
</li>
</ul>
<p>The compatibility equivalence forms are:</p>
<ul class="simple">
<li><p>Normalization Form KD = <code class="docutils literal notranslate"><span class="pre">NFKD</span></code></p>
<ul>
<li><p>All codepoints have gone through full, recursive canonical
decomposition and full, recursive compatibility decomposition</p></li>
</ul>
</li>
<li><p>Normalization Form KC = <code class="docutils literal notranslate"><span class="pre">NFKC</span></code></p>
<ul>
<li><p>All codepoints have gone through full, recursive canonical
decomposition and full, recursive compatibility decomposition,
followed by full canonical composition</p></li>
</ul>
</li>
</ul>
</section>
<section id="unicode-canonical-combining-classes">
<h3>Unicode canonical combining classes<a class="headerlink" href="#unicode-canonical-combining-classes" title="Permalink to this heading">¶</a></h3>
<p>The Unicode <code class="docutils literal notranslate"><span class="pre">Canonical_Combining_Class</span></code> (<code class="docutils literal notranslate"><span class="pre">Ccc</span></code>) property holds a
numerical value for every codepoint. It can be used to sort sequences
into canonical order.</p>
<p>Base letters, other non-mark codepoints, and spacing mark codepoints
will have <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> of <code class="docutils literal notranslate"><span class="pre">0</span></code>, meaning that the codepoint is unaffected by
the reordering algorithm.</p>
<p>Combining marks can have <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> values from <code class="docutils literal notranslate"><span class="pre">1</span></code> to <code class="docutils literal notranslate"><span class="pre">254</span></code>. The
reordering algorithm sorts subsequences of adjacent marks into order
of increasing <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> values.</p>
</section>
<section id="unicode-normalization-algorithm">
<h3>Unicode normalization algorithm<a class="headerlink" href="#unicode-normalization-algorithm" title="Permalink to this heading">¶</a></h3>
<p>The general Unicode normalization algorithm is structured to produce
output in the user’s preference between the four normalization
forms. So the steps performed vary based on whether the desired output
is to be in form <code class="docutils literal notranslate"><span class="pre">NFD</span></code>, <code class="docutils literal notranslate"><span class="pre">NFC</span></code>, <code class="docutils literal notranslate"><span class="pre">NFKD</span></code>, or <code class="docutils literal notranslate"><span class="pre">NFKC</span></code>.</p>
<blockquote>
<div><p>Note: The end goal of OpenType shaping normalization is not to
produce these Unicode-specified normalization forms, but to produce
the optimal rendered output. That is why a modified normalization
algorithm, as described in the next section, is used for shaping
text.</p>
</div></blockquote>
<p>The general Unicode normalization algorithm applies to all text except
Hangul syllables. It involves three stages:</p>
<ol class="arabic simple">
<li><p>Full decomposition:</p></li>
</ol>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">NFD</span></code> or <code class="docutils literal notranslate"><span class="pre">NFC</span></code> is the desired output, recursively apply
canonical decomposition mappings</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">NFKD</span></code> or <code class="docutils literal notranslate"><span class="pre">NFKC</span></code> is the desired output, recursively apply
canonical decomposition mappings followed by compatibility
decomposition mappings</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>Canonical reordering:</p></li>
</ol>
<ul class="simple">
<li><p>Sort all subsequences that consist of <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">0</span></code> codepoints
into order of increasing <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> value</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>Recomposition, if desired:</p></li>
</ol>
<ul class="simple">
<li><p>If either <code class="docutils literal notranslate"><span class="pre">NFD</span></code> or <code class="docutils literal notranslate"><span class="pre">NFKD</span></code> is the desired output, stop.</p></li>
<li><p>If either <code class="docutils literal notranslate"><span class="pre">NFC</span></code> or <code class="docutils literal notranslate"><span class="pre">NFKC</span></code> is the desired output, apply canonical
recomposition</p></li>
</ul>
<p>Canonical recomposition segments the text run into chunks that begin
with “Starter” codepoints (which have <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> = <code class="docutils literal notranslate"><span class="pre">0</span></code>) and progressively
tests the subsequent codepoints in the chunk, recombining them, in
order, with the starter whenever all of the following is true:</p>
<ul class="simple">
<li><p>there is a canonical <code class="docutils literal notranslate"><span class="pre">Decomposition_Mapping</span></code> for the “Starter,
Subsequent_codepoint” pair</p></li>
<li><p>the codepoint of the canonical <code class="docutils literal notranslate"><span class="pre">Decomposition_Mapping</span></code> does not
have the <code class="docutils literal notranslate"><span class="pre">Composition_Exclusion</span></code> or <code class="docutils literal notranslate"><span class="pre">Full_Composition_Exclusion</span></code>
properties</p></li>
<li><p>there are no characters of <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> = <code class="docutils literal notranslate"><span class="pre">0</span></code> or of a higher <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> value
than the starter between the starter and the subsequent codepoint</p></li>
</ul>
<p>In conceptual terms, the recomposition algorithm applies the reverse
of the decomposition mappings, except that the now-reordered sequence
may enable different pairings to match first.</p>
<p>The additional test conditions enable pairs to potentially match on
several decomposition mappings in a sequence where one base is
followed by several combining marks that attach at different
positions.</p>
<p>For example, in the fully decomposed and reordered sequence “Letter,
Mark_1, Mark_2”, if “Letter, Mark_1” is not part of a canonical
<code class="docutils literal notranslate"><span class="pre">Decomposition_Mapping</span></code> but “Letter, Mark_2” is part of a canonical
<code class="docutils literal notranslate"><span class="pre">Decomposition_Mapping</span></code>, then “Letter, Mark_2” will recombine into
“Letter-and-Mark_2”, followed by “Mark_1”.</p>
</section>
<section id="unicode-normalization-for-hangul-syllables">
<h3>Unicode normalization for Hangul syllables<a class="headerlink" href="#unicode-normalization-for-hangul-syllables" title="Permalink to this heading">¶</a></h3>
<p>Hangul syllables can be algorithmically composed and decomposed
because of the strict jamo-ordering of the codepoints that make up the
Hangul Syllables block.</p>
<p>Shaping engines can can use these algorithms to compose sequences of
individual jamo codepoints into precomposed-syllable codepoints, or to
compose individual jamo glyphs into a composite syllable when the
active font does not include a precomposed glyph for the required
syllable.</p>
<p>The algorithm used to normalize Hangul syllables is not related to the
Unicode normalization algorithm used for other scripts. The Hangul
algorithm is described in stage 2 of the <span class="xref myst">Hangul
shaping</span> document.</p>
</section>
</section>
<section id="opentype-shaping-normalization">
<h2>OpenType shaping normalization<a class="headerlink" href="#opentype-shaping-normalization" title="Permalink to this heading">¶</a></h2>
<p>Normalization for OpenType shaping closely follows the Unicode
normalization model, but it takes place in the context of a known text
run and a specific active font.</p>
<p>As a result, OpenType shaping takes the text context and available
font contents into account, making decisions intended to result in the
best possible output to the shaping process.</p>
<section id="goals">
<h3>Goals<a class="headerlink" href="#goals" title="Permalink to this heading">¶</a></h3>
<p>The OpenType shaping normalization algorithm also decomposes and
reorders the codepoints in a text run. But it differs from Unicode
normalization, particularly at the recomposition stage, in order to
offer the following features useful for shaping engines:</p>
<ol class="arabic simple">
<li><p>Different shaping models can request different preferred formats
(composed or decomposed) as output</p></li>
<li><p>Individual decomposition and recomposition mappings will not be
applied if doing so would result in a codepoint for which the
active font does not provide a glyph</p></li>
<li><p>Additional decompositions and recompositions not included in
Unicode are supported, including the decomposition of multi-part
dependent vowels (matras) in several Indic and Brahmic-derived
scripts as well as arbitrary decompositions and compositions
implemented in <code class="docutils literal notranslate"><span class="pre">ccmp</span></code> and <code class="docutils literal notranslate"><span class="pre">locl</span></code> GSUB lookups</p></li>
</ol>
</section>
<section id="shaping-model-preferences">
<h3>Shaping model preferences<a class="headerlink" href="#shaping-model-preferences" title="Permalink to this heading">¶</a></h3>
<p>Each shaping model supported by an OpenType shaping engine should
request its preferred normalization form: either fully composed or
fully decomposed.</p>
<blockquote>
<div><p>Note: in both cases, the preferred normalization form should be
understood as considering only canonical decomposition mappings, not
compatibility decomposition mappings.</p>
</div></blockquote>
<p>Which form is preferred for the model primarily depends on the details
of the model, such as whether or not generic Unicode recomposition is
known to interfere with mark positioning, reordering, or other shaping
operations.</p>
<p>Complex shaping models, particularly those which may involve
reordering or the positioning of multi-part marks, tend to prefer
decomposed forms. Nevertheless, deciding which form is preferred for
which model is an implementation decision ultimately left up to the
shaping-engine implementor, who can take speed, complexity, and other
trade-offs into account.</p>
<p>The preferred form may also be specific to a language, such as when a
minority language employs different diacritic ordering than the
ordering encoded in Unicode’s <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> data. In this case, a font
targetting the minority language may be expected to handle
language-specific mark-to-mark positioning in GPOS; as a result, the
shaping engine should allow for the positioning lookups by designating
a preference for decomposed forms.</p>
<p>Although a generic Unicode normalization implementation would target
the forms defined in Unicode (<code class="docutils literal notranslate"><span class="pre">NFD</span></code>, <code class="docutils literal notranslate"><span class="pre">NFC</span></code>, <code class="docutils literal notranslate"><span class="pre">NFKD</span></code>, or <code class="docutils literal notranslate"><span class="pre">NFKC</span></code>),
OpenType shaping preferred forms are not identical to these Unicode
forms and should not be advertized as being functionally equivalent.</p>
<p>Scripts and languages may also benefit from defining other preferred
forms beyond “fully decomposed” and “fully recomposed.” For example,
it might be useful to define a preferred form in which all sequences
of marks are recomposed, but base-and-mark sequences are not
recomposed.</p>
</section>
<section id="opentype-shaping-normalization-algorithm">
<h3>OpenType shaping normalization algorithm<a class="headerlink" href="#opentype-shaping-normalization-algorithm" title="Permalink to this heading">¶</a></h3>
<p>Opentype shaping normalization consists of four main stages.</p>
<ol class="arabic simple">
<li><p>Full decomposition</p></li>
<li><p>Canonical reordering</p></li>
<li><p>Selective recomposition</p></li>
<li><p>Applying font-specific normalization features</p></li>
</ol>
<p>Distinctions from Unicode normalization at each stage are described
below.</p>
<section id="decomposition">
<h4>1. Decomposition<a class="headerlink" href="#decomposition" title="Permalink to this heading">¶</a></h4>
<p>In the first stage, full <code class="docutils literal notranslate"><span class="pre">NFD</span></code> decomposition is performed, as in
Unicode normalization, except for a small set of exceptions required
by specific shapers:</p>
<ul class="simple">
<li><p>recursively apply canonical decomposition mappings, except for:</p>
<ul>
<li><p>Devanagari “Rra”</p></li>
<li><p>Bengali “Rra” and “Rha”</p></li>
<li><p>Tamil “Au”</p></li>
</ul>
</li>
</ul>
<p>After this decomposition, a second set of non-canonical and non-Unicode
mappings is applied:</p>
<ul>
<li><p>Several scripts (including many covered in the Indic2 shaping
model, as well as several other Brahmic-derived scripts) include
multi-part dependent vowel (matra) characters that should be
decomposed into multiple glyphs, so that those glyphs can be
independently positioned around base letters.</p>
<p>These additional decompositions are listed in the individual
script-shaping documents.</p>
</li>
<li><p>Shaping engines implementing fallback support for older encodings
should remap those older codepoints to their updated values.
For example, a shaper that supports text using the Arabic
Presentation Forms block should remap the Arabic Presentation
Forms codepoints to the corresponding Arabic-block default
codepoints and GSUB positional features.</p>
<p>These substitutions are defined in a set of Unicode compatibility
decomposition mappings.</p>
</li>
<li><p>Certain punctuation and symbol codepoints should be remapped, such as
remapping “non-breaking hyphen” codepoints to “hyphen”.</p></li>
</ul>
<p>Some of these additional decompositions and mappings may also be
implemented in and active font’s GSUB lookups, but that is not
guaranteed. Consequently, a normalization function must implement them
in order to fulfill the goal of providing stable output.</p>
</section>
<section id="canonical-reordering">
<h4>2. Canonical reordering<a class="headerlink" href="#canonical-reordering" title="Permalink to this heading">¶</a></h4>
<p>In the second stage, mark sequences are reordered into canonical
order:</p>
<ul class="simple">
<li><p>Sort all subsequences that consist of <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">0</span></code> codepoints
into order of increasing <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> value</p></li>
</ul>
<p>Several script-specific shapers require additional reordering to
compensate for limitations in the Unicode <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> mark-reordering
model. For example, several Arabic mark sequences are reordered in
<span class="xref myst">stage 1</span> of the Arabic
shaping model and <span class="xref myst">stage 1</span>
of the Syriac shaping model.</p>
<p>These are listed briefly in stage 4, step 4, below, but full
discussion of each case can be found in each script’s shaping
document.</p>
</section>
<section id="selective-recomposition">
<h4>3. Selective recomposition<a class="headerlink" href="#selective-recomposition" title="Permalink to this heading">¶</a></h4>
<p>The recomposition stage is selective and depends on the form requested
by the shaping model in use:</p>
<ul class="simple">
<li><p>If the shaping model prefers composed forms, then proceed with
recomposition as described in step 3.1</p></li>
<li><p>If the shaping model prefers decomposed forms, then proceed with
the recomposition as described in step 3.2</p></li>
</ul>
<section id="recomposition-for-composed-form-preference">
<h5>3.1 Recomposition for composed-form preference<a class="headerlink" href="#recomposition-for-composed-form-preference" title="Permalink to this heading">¶</a></h5>
<p>If composed forms have been requested, then proceed as in the Unicode
canonical recomposition algorithm: segment the text run into chunks
that begin with “Starter” codepoints (which have <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> = <code class="docutils literal notranslate"><span class="pre">0</span></code>) and
progressively tests the subsequent codepoints in the chunk,
recombining them, in order, with the starter whenever all of the
test conditions are met.</p>
<p>The following test conditions must be true:</p>
<ul class="simple">
<li><p>there is a canonical <code class="docutils literal notranslate"><span class="pre">Decomposition_Mapping</span></code> for the “Starter,
Subsequent_codepoint” pair</p></li>
<li><p>the codepoint of the canonical <code class="docutils literal notranslate"><span class="pre">Decomposition_Mapping</span></code> does not
have the <code class="docutils literal notranslate"><span class="pre">Composition_Exclusion</span></code> or <code class="docutils literal notranslate"><span class="pre">Full_Composition_Exclusion</span></code>
properties</p></li>
<li><p>there are no characters of <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> = <code class="docutils literal notranslate"><span class="pre">0</span></code> or of a higher <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> value
than the starter between the starter and the subsequent codepoint</p></li>
<li><p>the starter and the subsequent codepoint are not both of <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> = <code class="docutils literal notranslate"><span class="pre">0</span></code></p></li>
<li><p>the glyph that results from applying the recomposition exists in
the active font</p></li>
</ul>
</section>
<section id="recomposition-for-decomposed-form-preference">
<h5>3.2 Recomposition for decomposed-form preference<a class="headerlink" href="#recomposition-for-decomposed-form-preference" title="Permalink to this heading">¶</a></h5>
<p>If decomposed forms have been requested, then a simple check is
performed to cope with any decomposed forms that are absent in the
active font.</p>
<p>Segment the text run into chunks that begin with “Starter” codepoints
(which have <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> = <code class="docutils literal notranslate"><span class="pre">0</span></code>) and progressively tests the subsequent
codepoints in the chunk.</p>
<ul class="simple">
<li><p>If there is no standalone glyph for the subsequent codepoint, but
there is a <code class="docutils literal notranslate"><span class="pre">Decomposition_Mapping</span></code> for the “Starter, subsequent
codepoint” pair and a glyph exists for the recomposed codepoint,
then recombine the starter and the subsequent codepoint</p></li>
</ul>
<!---
HARFBUZZ logic here: https://github.com/harfbuzz/harfbuzz/src/hb-ot-shape-normalize.cc#L425
--->
</section>
</section>
<section id="normalization-related-gsub-features-and-other-font-specific-considerations">
<h4>4. Normalization-related GSUB features and other font-specific considerations<a class="headerlink" href="#normalization-related-gsub-features-and-other-font-specific-considerations" title="Permalink to this heading">¶</a></h4>
<p>After the decomposition, mark-reordering, and selective
recomposition stages, OpenType shaping normalization also takes
certain GSUB lookups and complex-script shaping operations into
consideration.</p>
<p>These additional operations may produce final output that differs
from Unicode <code class="docutils literal notranslate"><span class="pre">NFD</span></code> and <code class="docutils literal notranslate"><span class="pre">NFC</span></code> forms. However, the output from stage
four should be identical for any two canonically-equivalent input
sequences in the same active font and script/language context.</p>
<blockquote>
<div><p>Note: the features discussed below are applied after the completion
of the decomposition, mark-reordering, and recomposition
stages. Furthermore, they are applied before any other GSUB and GPOS
features.</p>
<p>As a result, shaping engine implementors may choose to
defer application of these features to the start of GSUB and GPOS
processing for the sake of convenience.</p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">ccmp</span></code> and <code class="docutils literal notranslate"><span class="pre">locl</span></code> features can involve normalization, as described
below. If they are present in the active font and match the text run,
all <code class="docutils literal notranslate"><span class="pre">ccmp</span></code> and <code class="docutils literal notranslate"><span class="pre">locl</span></code> features should be applied, and should be
applied in the order in which they are listed in the GSUB table.</p>
<section id="ccmp-features">
<h5>4.1 <code class="docutils literal notranslate"><span class="pre">ccmp</span></code> features<a class="headerlink" href="#ccmp-features" title="Permalink to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">ccmp</span></code> feature is applied to all text runs. <code class="docutils literal notranslate"><span class="pre">ccmp</span></code> lookups are not
meant be to be disabled by end users in application code.</p>
<p><code class="docutils literal notranslate"><span class="pre">ccmp</span></code> lookups can specify arbitrary decomposition mappings and
composition mappings, via one-to-many or many-to-one GSUB
substitutions.</p>
<p>These lookups should be applied regardless of whether
they correspond to the expected decomposition and recomposition
mappings in Unicode, because <code class="docutils literal notranslate"><span class="pre">ccmp</span></code> is font-specific.</p>
<p>A common usage of <code class="docutils literal notranslate"><span class="pre">ccmp</span></code> is to decompose a single codepoint into two
or more glyphs representing discrete components, so that those
components can be more precisely positioned.</p>
<p>For example, many Arabic letters include ijam: dots that, while they
may visually resemble marks, are instead intrinsic components of the
letter and not diacritics. Because the ijam are not marks, a letter
with ijam does not decompose to separate Unicode codepoints. By
decomposing the letter into discrete base and ijam glyphs in <code class="docutils literal notranslate"><span class="pre">ccmp</span></code>, a
font can implement better contextual positioning of the ijam, and can
do so with considerably less work than including numerous alternate
glyphs.</p>
<!--- comment from the HarfBuzz source code that I am not
      certain of the meeting of:
"When a font has a precomposed character for a sequence but the 'ccmp'
feature in the font is not adequate, use the precomposed character
which typically has better mark positioning."
--->
</section>
<section id="locl-features">
<h5>4.2 <code class="docutils literal notranslate"><span class="pre">locl</span></code> features<a class="headerlink" href="#locl-features" title="Permalink to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">locl</span></code> feature is applied to text runs based on matching script
and language tags.</p>
<p>When the tags match, any lookups in <code class="docutils literal notranslate"><span class="pre">locl</span></code> are applied by default
during shaping, and these lookups are not meant be to be disabled by
end users in application code.</p>
<p><code class="docutils literal notranslate"><span class="pre">locl</span></code> lookups often implement simple one-to-one substitutions to
replace default glyph forms with alternate shapes preferred in the
language/script combination.</p>
<p>However, <code class="docutils literal notranslate"><span class="pre">locl</span></code> lookups may also interact with normalization by
performing decompositions or compositions. These substitutions are
often used to preserve orthographic or linguistic features that are
not fully captured by Unicode normalization forms or <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> ordering.</p>
<p>For example, in the Turkish alphabet, “dotted i” and “dotless i” are
two distinct letters. For runs of text in Turkish, a font may
deliberately substitute a generic “i” glyph with “dotted i” or the “i,
dot diacritic” sequence with <code class="docutils literal notranslate"><span class="pre">locl</span></code> lookups in order to ensure that
the dot diacritic is not lost as text is processed.</p>
<p>Or, for example, in a particular script and language pairing, readers
might expect or prefer certain sequences of diacritics to stack in a
different order than the order their Unicode <code class="docutils literal notranslate"><span class="pre">Ccc</span></code> values dictate. A
<code class="docutils literal notranslate"><span class="pre">locl</span></code> lookup could be used to implement the preferred reordering in a
many-to-one GSUB substitution.</p>
</section>
<section id="variation-selectors">
<h5>4.3 Variation Selectors<a class="headerlink" href="#variation-selectors" title="Permalink to this heading">¶</a></h5>
<p>Unicode defines <em>standardized_variation_sequences</em> as sequences of two
codepoints where the first codepoint is any base character or mark,
and the second character is a Variation Selector. Mapping a
standardized variation sequence to a glyph is not done via GSUB,
however, but in the <code class="docutils literal notranslate"><span class="pre">cmap</span></code> table of a font.</p>
<p>Unicode normalization does not consider Variation Selector
codepoints.</p>
<p>When performing OpenType shaping normalization, however, if the
“letter, Variation Selector” is not mapped to a glyph in the active
font, a shaping engine may prefer to drop the Variation Selector
codepoint and render the default form of the character or to replace
the sequence with a <code class="docutils literal notranslate"><span class="pre">.notdef</span></code> glyph. Which option is preferred may be
language- or script-specific.</p>
</section>
</section>
<section id="interaction-with-script-specific-shaping-models">
<h4>4.4 Interaction with script-specific shaping models<a class="headerlink" href="#interaction-with-script-specific-shaping-models" title="Permalink to this heading">¶</a></h4>
<p>Reordering and composition are defined as shaping operations in
several script-specific shaping models. In some cases, a reordering
operation or composition may be designated by a particular GSUB or
GPOS feature tag.</p>
<p>Shaping-engine implementors should take care to note where completing
normalization early in the shaping process may reduce the need for
applying such operations later.</p>
<p>For example, in the Indic2 shaping model, sequences of marks are
reordered in stage 2, step 4. But this reordering is identical to the
Unicode canonical reordering, so a shaping-engine implementation that
normalizes all text runs before starting the Indic2 shaping process
will not need to perform any reordering at that step — assuming that
the Indic2 shaping model is configured to prefer decomposed forms.</p>
<p>Similarly, in stage 3, step 2 of the Indic2 shaping model, the <code class="docutils literal notranslate"><span class="pre">nukt</span></code>
feature composes “Base, Nukta” sequences into “Base-and-Nukta”
glyphs. A shaping engine that designates the Indic2 shaping model as
preferring composed forms could, therefore, have such “Base, Nukta”
sequences recomposed during Unicode normalization. However, such a
recomposition preference would likely cause other problems, such as
the unwanted recomposition of multi-part dependent vowels (matras).</p>
<p>Script-specific shaping models can also involve special exceptions to
the generic composition and reordering process of normalization. For
example:</p>
<ul class="simple">
<li><p>In the Hebrew shaper, stage 2, Hebrew Alphabetic Presentation
Forms, if available in the active font, are composed.</p></li>
<li><p>In the Arabic shaping model, stage 1, and in the Syriac shaping
model, stage 1, certain marks are reordered after normalization
and after GSUB feature application.</p></li>
<li><p>In Bengali, “Ya, Nukta” is composed into “Yya” before GSUB feature
application, to avoid potential ambiguities during the application
of later features.</p></li>
</ul>
</section>
<section id="compatibility-decompositions">
<h4>Compatibility decompositions<a class="headerlink" href="#compatibility-decompositions" title="Permalink to this heading">¶</a></h4>
<p>As was mentioned in stage 1 of the OpenType shaping normalization
algorithm, the codepoints in the Arabic Presentation Forms blocks
have Unicode compatibility <code class="docutils literal notranslate"><span class="pre">Decomposition_Mapping</span></code>s that a shaping
engine can use to map codepoints from Arabic Presentation Forms to
codepoints in the Arabic block. Each Arabic Presentation Form
<code class="docutils literal notranslate"><span class="pre">Decomposition_Mapping</span></code> is tagged with a positional tag corresponding
to a positional GSUB feature: <code class="docutils literal notranslate"><span class="pre">&lt;final&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;initial&gt;</span></code>,<code class="docutils literal notranslate"><span class="pre">&lt;isolated&gt;</span></code>, or
<code class="docutils literal notranslate"><span class="pre">&lt;medial&gt;</span></code>.</p>
<p>This tag information can be used to construct a set of synthetic GSUB
lookups corresponding to <code class="docutils literal notranslate"><span class="pre">fina</span></code>, <code class="docutils literal notranslate"><span class="pre">init</span></code>, <code class="docutils literal notranslate"><span class="pre">isol</span></code>, and <code class="docutils literal notranslate"><span class="pre">medi</span></code>. However,
shaping engines should take care not to offer guarantees about the
expect output, unless explicit support for older files known to be
encoded with Arabic Presentation Forms codepoints is desired.</p>
<p>Similarly, several other compatibility <code class="docutils literal notranslate"><span class="pre">Decomposition_Mapping</span></code> tags
could theoretically be exploited to enable some level of fallback
support for shaping codepoints when the necessary glyphs are missing
in the active font, such as mapping <code class="docutils literal notranslate"><span class="pre">&lt;fraction&gt;</span></code> decompositions to
<code class="docutils literal notranslate"><span class="pre">frac</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;super&gt;</span></code> decompositions to <code class="docutils literal notranslate"><span class="pre">sups</span></code>,  <code class="docutils literal notranslate"><span class="pre">&lt;sub&gt;</span></code> to <code class="docutils literal notranslate"><span class="pre">subs</span></code> or
<code class="docutils literal notranslate"><span class="pre">sinf</span></code>, or <code class="docutils literal notranslate"><span class="pre">&lt;compat&gt;</span></code> to various generic list-item delimiter
sequences.</p>
<p>All such decompositions, however, should be implemented as
fallbacks and the decision to employ them is best left up to the
application layer or end user’s preferences.</p>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">OpenType Shaping Documents</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=n8willis&repo=opentype-shaping-documents&type=watch&count=True&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="README.html">Scripts</a></li>
    
    <li class="toctree-l1"><a href="character-tables/character-tables-index.html">Character tables</a></li>
    
    <li class="toctree-l1"><a href="opentype-shaping-normalization.html">Normalization</a></li>
    
    <li class="toctree-l1"><a href="notes/README.html">Notes</a></li>
    
    <li class="toctree-l1"><a href="errata.html">Errata</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Sponsored by YesLogic.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/opentype-shaping-normalization.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>